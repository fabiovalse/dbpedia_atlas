// Generated by CoffeeScript 1.4.0
(function() {
  var C, CELL_RADIUS, GRID_HEIGHT, GRID_WIDTH, M, REGION_LABEL_MIN_AREA, SIMPLIFICATION, SIZE, cities_layer, cos30, cursor, cursor_layer, data_props_density_color, defs, depth_color, dx, dy, inset_color, land_layer, leaf_labels_layer, map_layer, obj_props_density_color, path_generator, region_labels_layer, relations_layer, sea_layer, sin30, svg, triple_density_color, vis, zoom_layer, _draw_leaf_labels, _get_hexagon, _hex_path, _ij_to_xy, _init_modes, _move_cursor, _on_hex_click, _preprocess, _preprocess_selection, _update_lod;

  window.map = {};

  /* globals
  */

  svg = null;

  defs = null;

  zoom_layer = null;

  vis = null;

  map_layer = null;

  cursor = null;

  sea_layer = null;

  land_layer = null;

  leaf_labels_layer = null;

  cities_layer = null;

  relations_layer = null;

  region_labels_layer = null;

  cursor_layer = null;

  SIZE = 100;

  CELL_RADIUS = 0.1;

  sin30 = Math.sin(Math.PI / 6);

  cos30 = Math.cos(Math.PI / 6);

  map.init = function(dom_node) {
    var bcr, bluerect, placemark, sea_pattern, u_px_ratio;
    svg = d3.select(dom_node);
    map.node = svg;
    svg.attr({
      viewBox: "" + (-SIZE / 2) + " " + (-SIZE / 2) + " " + SIZE + " " + SIZE
      //viewBox: "" + (-SIZE / 2) + " " + (-SIZE / 30) + " " + SIZE + " " + SIZE/4
    });
    defs = svg.append('defs');
    /* define sea pattern
    */

    sea_pattern = defs.append('pattern').attr({
      id: 'sea_pattern',
      x: 0,
      y: 0,
      width: 30,
      height: 30,
      patternUnits: 'userSpaceOnUse'
    });
    sea_pattern.append('path').attr({
      d: 'M0 0.5 L 10 0.5',
      stroke: 'rgba(30,0,0,0.4)',
      'stroke-width': '0.3'
    });
    sea_pattern.append('path').attr({
      d: 'M15 15.5 L 25 15.5',
      stroke: 'rgba(30,0,0,0.4)',
      'stroke-width': '0.3'
    });
    /* init test
    */

    svg.append('rect').attr({
      "class": 'debug',
      x: -SIZE / 2,
      y: -SIZE / 2,
      width: SIZE,
      height: SIZE,
      stroke: 'red'
    });
    bcr = svg.node().getBoundingClientRect();
    u_px_ratio = SIZE / Math.min(bcr.width, bcr.height);
    bluerect = svg.append('rect').attr({
      "class": 'debug',
      x: -bcr.width / 2 * u_px_ratio,
      y: -bcr.height / 2 * u_px_ratio,
      width: bcr.width * u_px_ratio,
      height: bcr.height * u_px_ratio,
      stroke: 'blue'
    });
    d3.select(window).on('resize', function() {
      bcr = svg.node().getBoundingClientRect();
      u_px_ratio = SIZE / Math.min(bcr.width, bcr.height);
      return bluerect.attr({
        x: -bcr.width / 2 * u_px_ratio,
        y: -bcr.height / 2 * u_px_ratio,
        width: bcr.width * u_px_ratio,
        height: bcr.height * u_px_ratio,
        stroke: 'green'
      });
    });
    /* END init test
    */

    /* ZOOM and PAN
    */

    zoom_layer = svg.append('g');
    svg.call(d3.behavior.zoom().scaleExtent([0.3, 600]).on('zoom', function() {
      zoom_layer.attr({
        transform: "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")"
      });
      /* semantic zooming
      */

      zoom_layer.selectAll('.label').attr({
        transform: "scale(" + (1 / d3.event.scale) + ") rotate(60)"
      });
      cursor.select('.placemark').attr({
        transform: "scale(" + (1 / d3.event.scale) + ") scale(0.2) rotate(60)"
      });
      /* LOD
      */

      return _update_lod(d3.event.scale);
    }));
    vis = zoom_layer.append('g').attr({
      transform: 'translate(-10,-15) rotate(-60)'
    });
    map_layer = vis.append('g');
    sea_layer = map_layer.append('g');
    land_layer = map_layer.append('g');
    leaf_labels_layer = map_layer.append('g');
    relations_layer = map_layer.append('g');
    relations_layer.append('g').attr({
      "class": 'links'
    });
    cities_layer = map_layer.append('g');
    region_labels_layer = map_layer.append('g');
    cursor_layer = map_layer.append('g');
    /* cursor
    */

    cursor = cursor_layer.append('g').attr({
      "class": 'cursor'
    }).style({
      display: 'none'
    });
    cursor.append('path').attr({
      "class": 'hex_cell',
      d: _hex_path
    });
    placemark = cursor.append('g').attr({
      "class": 'placemark',
      transform: 'scale(0.2) rotate(60)'
    });
    placemark.append('path').attr({
      "class": 'placemark_symbol',
      d: 'm 0,-16 c -3.1862583,0 -5.7692313,2.583 -5.7692313,5.7692 0,1.3042 0.424081,2.4953 1.153846,3.4616 L 0,0 l 4.615385,-6.7692 c 0.729765,-0.9663 1.153846,-2.1574 1.153846,-3.4616 0,-3.1862 -2.582973,-5.7692 -5.769231,-5.7692 z'
    });
    placemark.append('circle').attr({
      "class": 'placemark_dot',
      cy: -10,
      r: 2.1
    });
    /*land_layer.on('click', function() {
      return _on_hex_click(_get_hexagon(d3.mouse(this)), true);
    });*/
  };

  _on_hex_click = function(hex, typed) {
    if (d3.event.defaultPrevented) {
      return;
    }
    /* move the cursor to provide feedback
    */

    /*_move_cursor(hex[0], hex[1], typed);*/
    /* trigger a selection event
    */

    return trigger(map.node, 'select', {
      i: hex[0],
      j: hex[1]
    });
  };

  /* custom projection to make hexagons appear regular (y axis is also flipped)
  */


  dx = CELL_RADIUS * 2 * Math.sin(Math.PI / 3);

  dy = CELL_RADIUS * 1.5;

  SIMPLIFICATION = 15;

  path_generator = d3.geo.path().projection(d3.geo.transform({
    point: function(x, y, z) {
      /* Level of Detail
      */
      if (z >= SIMPLIFICATION) {
        return this.stream.point(x * dx / 2, -(y - (2 - (y & 1)) / 3) * dy / 2);
      }
    }
  }));

  map.load = function(data, stats_data) {
    var cities, cities_data, enter_cities, enter_region_labels, enter_region_labels_foreground, enter_region_labels_halo, region_clips, region_labels, ux, uy, _ref;
    _preprocess(data, stats_data);
    _init_modes();
    /* fill the sea
    */

    /* cover the sea with a pattern
    */

    sea_layer.append('rect').attr({
      id: 'sea',
      width: 10000,
      height: 10000,
      x: -5000,
      y: -5000,
      fill: 'url(#sea_pattern)',
      transform: 'scale(0.05) rotate(60)'
    });
    /* define the level zero region (the land)
    */

    /*defs.append('path').datum(topojson.mesh(data, data.objects.leaf_regions, function(a, b) {
      return a === b;
    })).attr('id', 'land').attr('d', path_generator);*/
    sea_layer.selectAll('.land-glow-outer').data(topojson.feature(data, data.objects.leaf_regions).features).enter().append('path').attr({
      "class": 'land-glow-outer land-glow-inner',
      d: path_generator,
      "transform": function(d) {
        return "translate(" + d.properties.dx + ", " + d.properties.dy + ")";
      }
    });
    /* faux land glow (using filters takes too much resources)
    */

    /*sea_layer.append('use').attr('class', 'land-glow-outer').attr('xlink:href', '#land');
    sea_layer.append('use').attr('class', 'land-glow-inner').attr('xlink:href', '#land');*/
    /* actual regions
    */

    land_layer.selectAll('.leaf_region').data(topojson.feature(data, data.objects.leaf_regions).features).enter().append('path').attr({
      "class": 'leaf_region',
      d: path_generator,
      "transform": function(d) {
        return "translate(" + d.properties.dx + ", " + d.properties.dy + ")";
      }
    })
    .on('click', function() {
      return _on_hex_click(_get_hexagon(d3.mouse(this)), true);
    });
    /* draw the leaf regions boundaries
    */

    /*land_layer.append('path')
      .datum(topojson.mesh(data, data.objects.leaf_regions, function(a, b) {
        return a !== b && a.properties.path[1] === b.properties.path[1];
      })).attr('d', path_generator).attr('class', 'boundary low').style('stroke-width', '0.5px');*/
    /* draw the level two boundaries
    */

    /*land_layer.append('path').datum(topojson.mesh(data, data.objects.leaf_regions, function(a, b) {
      return a.properties.path.length > 2 && b.properties.path.length > 2 && a.properties.path[1] === b.properties.path[1] && a.properties.path[2] !== b.properties.path[2];
    })).attr('d', path_generator).attr('class', 'boundary low').style('stroke-width', '0.9px');*/
    /* inset clipping of level one regions
    */

    region_clips = land_layer.selectAll('.region_clip').data(ontology.levels[1]);
    region_clips.enter().append('clipPath').attr({
      "class": function(d) {return (d.name != "http://data.linkedmdb.org/resource/untyped" ? 'region_clip' : 'untyped_island');},
      id: function(n) {
        return "region_clip-" + n.name;
      }
    }).append('path').attr({
      d: function(n) {
        return path_generator(n.merged_region);
      }
    });
    land_layer.selectAll('.high_region').data(ontology.levels[1]).enter().append('path').attr({
      "class": function(d) {return (d.name != "http://data.linkedmdb.org/resource/untyped" ? 'high_region' : 'untyped_island');},
      d: function(n) {
        return path_generator(n.merged_region);
      },
      'clip-path': function(n) {
        return "url(#region_clip-" + n.name + ")";
      },
      "transform": function(d) {
        return "translate(" + d.leaf_region.properties.dx + ", " + d.leaf_region.properties.dy + ")";
      }
    });
    /* draw the high-level boundaries
    */


    land_layer.selectAll('.boundary').data(topojson.feature(data, data.objects.leaf_regions).features).enter().append('path').attr({
      "class": function(d) {
        return (d.properties.class != "http://data.linkedmdb.org/resource/untyped" ? 'boundary high' : 'untyped_island');},
      d: path_generator,
      "transform": function(d) {
        return "translate(" + d.properties.dx + ", " + d.properties.dy + ")";
      }
    }).style('stroke-width', '1.1px');

    /*land_layer.append('path').datum(topojson.mesh(data, data.objects.leaf_regions, function(a, b) {
      return a === b || a.properties.path[1] !== b.properties.path[1];
    })).attr('d', path_generator).attr('class', 'boundary high').style('stroke-width', '1.1px');*/
    /* draw labels of leaf regions
    */

    _draw_leaf_labels();
    /* draw notable entities (cities)
    */

    cities_data = [
      /*{
        "uri": "http://dbpedia.org/resource/Freddie_Mercury",
        "i": 1232,
        "j": -918
      }*/
    ];
    cities = cities_layer.selectAll('.city').data(cities_data);
    enter_cities = cities.enter().append('g').on('click', function(c) {
      /* trigger the selection of the city
      */
      return trigger(map.node, 'select', {
        uri: c.uri
      });
    }).attr({
      "class": 'city',
      transform: function(c) {
        var x, y, _ref1;
        _ref1 = _ij_to_xy(c.i, c.j), x = _ref1[0], y = _ref1[1];
        return "translate(" + x + "," + y + ")";
      }
    });
    enter_cities.append('text').text(function(c) {
      return decodeURI(c.uri.replace('http://dbpedia.org/resource/', '').replace(/_/g, ' '));
    }).attr({
      "class": 'label halo',
      dx: 0.5,
      dy: -0.5,
      transform: 'rotate(60)'
    });
    enter_cities.append('text').text(function(c) {
      return decodeURI(c.uri.replace('http://dbpedia.org/resource/', '').replace(/_/g, ' '));
    }).attr({
      "class": 'label foreground',
      dx: 0.5,
      dy: -0.5,
      transform: 'rotate(60)'
    });
    enter_cities.append('path').attr({
      "class": 'hex_cell',
      d: _hex_path
    });
    /* region labels
    */

    region_labels = region_labels_layer.selectAll('.region_label').data(ontology.levels[1].filter(function(n) {
      return n.merged_region.coordinates.length > 0;
    }));
    enter_region_labels = region_labels.enter().append('g').attr({
      "class": function(d) {
        return (d.name != "http://data.linkedmdb.org/resource/untyped") ? 'region_label' : 'untyped_island_label region_label'},
      transform: function(n) {
        return "translate(" + (n.x + n.leaf_region.properties.dx) + "," + (n.y + n.leaf_region.properties.dy) + ")";
      }
    });
    enter_region_labels_halo = enter_region_labels.append('text').attr({
      "class": 'halo label',
      transform: 'rotate(60)',
      y: function(n) {
        return -(Math.floor(n.readable_label.length / 2) * 1.2 + 0.35) + 'em';
      }
    });
    enter_region_labels_halo.selectAll('tspan').data(function(n) {
      return n.readable_label;
    }).enter().append('tspan').text(function(t) {
      return t;
    }).attr({
      x: 0,
      dy: '1.2em'
    });
    enter_region_labels_foreground = enter_region_labels.append('text').attr({
      "class": 'label foreground',
      transform: 'rotate(60)',
      y: function(n) {
        return -(Math.floor(n.readable_label.length / 2) * 1.2 + 0.35) + 'em';
      }
    });
    enter_region_labels_foreground.selectAll('tspan').data(function(n) {
      return n.readable_label;
    }).enter().append('tspan').text(function(t) {
      return t;
    }).attr({
      x: 0,
      dy: '1.2em'
    });
    map.mode('classes');
    return _update_lod(1);
  };

  map.update_selection = function(selection) {
    var enter_relations, links, relations;
    _preprocess_selection(selection);
    
    translation_coordinates = ontology.get_translation_from_class((selection.types.length > 0) ? selection.types[0].value : "http://data.linkedmdb.org/resource/untyped");
    _move_cursor(selection.i, selection.j, translation_coordinates[0], translation_coordinates[1], selection.parent !== null);
    /* clear all relations and draw them again
    */

    relations_layer.selectAll('.relation_end').remove();
    relations_layer.select('.links').selectAll('.link').remove();
    relations = relations_layer.selectAll('.relation').data(selection.relations);
    enter_relations = relations.enter().append('path').attr({
      "class": 'relation_end hex_cell',
      d: _hex_path,
      transform: function(r) {
        object_translation_coordinates = (selection.uri == r.source.uri) ? ontology.get_translation_from_class(r.target.c) : ontology.get_translation_from_class(r.source.c);

        return "translate(" + (r.end.x + object_translation_coordinates[0]) + "," + (r.end.y + object_translation_coordinates[1]) + ")";
      }
    }).on('click', function(r) {
      /* trigger the selection of the relation end
      */
      return trigger(map.node, 'select', {
        uri: r.end.uri
      });
    });
    enter_relations.append('title').text(function(r) {
      //return format_uri(r.end.uri);
      return r.end.label;
    });
    /* show relation links
    */

    links = relations_layer.select('.links').selectAll('.link').data(selection.relations);
    return links.enter().append('path').attr({
      "class": 'link',
      d: function(r) {
        object_translation_coordinates = (selection.uri == r.source.uri) ? ontology.get_translation_from_class(r.target.c) : ontology.get_translation_from_class(r.source.c);

        return "M" + (r.start.x + translation_coordinates[0]) + " " + (r.start.y + translation_coordinates[1]) + " L" + (r.end.x + object_translation_coordinates[0]) + " " + (r.end.y + object_translation_coordinates[1]);
      }
    });
  };

  _ij_to_xy = function(i, j, typed) {
    if (!(typed != null)) {
      typed = true;
    }
    dx = 0;
    dy = 0;
    
    return [j * (cos30 * CELL_RADIUS * 2) + (i % 2 === 0 ? 0 : cos30 * CELL_RADIUS) + dx, i * 3 / 2 * CELL_RADIUS + dy];
  };

  _move_cursor = function(i, j, dx, dy, typed) {
    var x, y, _ref;
    if (!(typed != null)) {
      typed = true;
    }
    _ref = _ij_to_xy(i, j, typed), x = _ref[0], y = _ref[1];
    return cursor.attr({
      transform: "translate(" + (x + dx) + ", " + (y + dy) + ")"
    }).style({
      display: 'inline'
    });
  };

  /* find a hex given SVG coordinates
  */


  GRID_HEIGHT = sin30 * CELL_RADIUS * 3;

  GRID_WIDTH = cos30 * CELL_RADIUS * 2;

  C = sin30 * CELL_RADIUS;

  M = C / (GRID_WIDTH / 2);

  _get_hexagon = function(point) {
    var column, relX, relY, row, rowIsOdd, x, y;
    x = point[0] + cos30 * CELL_RADIUS;
    y = point[1] + CELL_RADIUS;
    row = Math.floor(y / GRID_HEIGHT);
    rowIsOdd = row % 2 === 1;
    if (rowIsOdd) {
      column = Math.floor((x - GRID_WIDTH / 2) / GRID_WIDTH);
    } else {
      column = Math.floor(x / GRID_WIDTH);
    }
    relY = y - (row * GRID_HEIGHT);
    if (rowIsOdd) {
      relX = x - (column * GRID_WIDTH) - GRID_WIDTH / 2;
    } else {
      relX = x - (column * GRID_WIDTH);
    }
    /* work out if the point is above either of the hexagon's top edges
    */

    if (relY < (-M * relX) + C) {
      row -= 1;
      if (!rowIsOdd) {
        column -= 1;
      }
    } else if (relY < (M * relX) - C) {
      row -= 1;
      if (rowIsOdd) {
        column += 1;
      }
    }
    return [row, column];
  };

  /* precomputed hexagonal path
  */


  _hex_path = "M0," + CELL_RADIUS + " L" + (cos30 * CELL_RADIUS) + "," + (sin30 * CELL_RADIUS) + " L" + (cos30 * CELL_RADIUS) + "," + (-sin30 * CELL_RADIUS) + " L0," + (-CELL_RADIUS) + " L" + (-cos30 * CELL_RADIUS) + "," + (-sin30 * CELL_RADIUS) + " L" + (-cos30 * CELL_RADIUS) + "," + (sin30 * CELL_RADIUS) + " Z";

  /* Level Of Detail
  */


  REGION_LABEL_MIN_AREA = 50;

  _update_lod = function(z) {
    //console.log(z);
    
    region_labels_layer.selectAll('.region_label').classed('hidden', function(n) {
      return n.area * z * z < REGION_LABEL_MIN_AREA;
    });
    return leaf_labels_layer.selectAll('.leaf_label').classed('hidden', function(n) {
      return n.area * z * z < REGION_LABEL_MIN_AREA;
    });
  };

  _preprocess = function(data, stats_data) {
    var geometries, _merge;
    map.leaf_regions = topojson.feature(data, data.objects.leaf_regions).features;
    geometries = data.objects.leaf_regions.geometries;
    /* parse paths into arrays, and extract the class of each leaf region
    */

    map.leaf_regions.forEach(function(f) {
      f.properties.path = JSON.parse(f.properties.path);
      return f.properties["class"] = f.properties.path[f.properties.path.length - 1];
    });
    /* presimplify the topologies (compute the effective area (z) of each point)
    */

    topojson.presimplify(data);
    /* store all leaf_regions into the ontology tree, and store each node within the feature's properties
    */

    map.leaf_regions.forEach(function(f) {
      var n;

      n = ontology.get_node_from_class(f.properties["class"]);

      n.leaf_region = f;
      return f.properties.node = n;
    });
    /* compute merged regions from leaf regions
    */

    _merge = function(n, depth) {
      n.merged_region = topojson.merge(data, geometries.filter(function(g) {
        return g.properties.path.length > depth && g.properties.path[depth] === n.name;
      }));
      if (n.children != null) {
        return n.children.forEach(function(c) {
          return _merge(c, depth + 1);
        });
      }
    };
    _merge(ontology.tree, 0);
    /* compute all region centroids
    */

    ontology.nodes.forEach(function(n) {
      var _ref;
      return _ref = path_generator.centroid(n.merged_region), n.x = _ref[0], n.y = _ref[1], _ref;
    });
    /* compute all region areas
    */

    ontology.nodes.forEach(function(n) {
      return n.area = path_generator.area(n.merged_region);
    });
    /* create a stats index
    */

    _stats = {};
    stats_data.forEach(function(s) {
      return _stats[s["class"]] = s;
    });
    /* add stats to each leaf region
    */

    map.leaf_regions.forEach(function(f) {
      f.properties.node.stats = _stats[f.properties.node.name];
      if (!(f.properties.node.stats != null)) {
        //console.error("Class not found in statistics data: " + f.properties.node.name);
      }
    });
    /* compute additional stats
    */

    map.leaf_regions.forEach(function(f) {
      if (f.properties.node.name != "http://data.linkedmdb.org/resource/untyped") {
        f.properties.node.stats.triple_density = f.properties.node.stats.triple_count / f.properties.node.leaf_count;
        f.properties.node.stats.obj_props_density = f.properties.node.stats.obj_props_count / f.properties.node.leaf_count;
        return f.properties.node.stats.data_props_density = f.properties.node.stats.data_props_count / f.properties.node.leaf_count;
      }
    });
    /* define readable, plural, multiline labels for level one regions
    */

    _readable_labels = {};
    ontology.nodes.forEach(function(d) { 
      _readable_labels[d.name] = d.name.split("/").slice(-1)[0].split("_");
    });

    ontology.levels[1].forEach(function(n) {
      return n.readable_label = _readable_labels[n.name];
    });
    return ontology.leaves.forEach(function(n) {
      if (n.depth > 1 && (n.leaf_region != null)) {
        return n.readable_label = _readable_labels[n.name];
      }
    });
  };

  _preprocess_selection = function(selection) {
    /* compute selection parent, if any
    */

    var _ref;
    if (selection.path.length > 0) {
      selection.parent = ontology.get_node_from_class(selection.path[selection.path.length - 1]);
    } else {
      selection.parent = null;
    }
    /* compute cartesian coordinates
    */

    _ref = _ij_to_xy(selection.i, selection.j, selection.parent != null), selection.x = _ref[0], selection.y = _ref[1];
    /* extract relational links
    */

    /* FIXME links to self are currently ignored
    */

    selection.relations = [];
    /* outgoing links
    */

    selection.object_properties.outgoing.forEach(function(t) {
      var ox, oy, path, _ref1;
      if ('i' in t && 'j' in t) {
        path = ontology.get_path(t.c);
        _ref1 = _ij_to_xy(t.i.value, t.j.value, path.length > 0), ox = _ref1[0], oy = _ref1[1];
        return selection.relations.push({
          source: selection,
          predicate: t.p.value,
          target: {
            uri: t.o.value,
            i: t.i.value,
            j: t.j.value,
            x: ox,
            y: oy,
            c: t.c[0].value,
            label: t.label.value,
            parent: path.length > 0 ? ontology.get_node_from_class(path[path.length - 1]) : null
          }
        });
      } else {
        return console.error('Link to out-of-map entity: ' + t.o.value);
      }
    });
    /* incoming links
    */

    selection.object_properties.incoming.forEach(function(t) {
      var path, sx, sy, _ref1;
      if ('i' in t && 'j' in t) {
        path = ontology.get_path(t.c);
        _ref1 = _ij_to_xy(t.i.value, t.j.value, path.length > 0), sx = _ref1[0], sy = _ref1[1];
        return selection.relations.push({
          source: {
            uri: t.s.value,
            i: t.i.value,
            j: t.j.value,
            x: sx,
            y: sy,
            c: t.c[0].value,
            label: t.label.value,
            parent: path.length > 0 ? ontology.get_node_from_class(path[path.length - 1]) : null
          },
          predicate: t.p.value,
          target: selection
        });
      } else {
        return console.error('Link from out-of-map entity: ' + t.s.value);
      }
    });
    /* pointers relative to current selection
    */

    return selection.relations.forEach(function(r) {
      if (r.source === selection) {
        r.start = r.source;
        return r.end = r.target;
      } else {
        r.start = r.target;
        return r.end = r.source;
      }
    });
  };

  inset_color = null;

  depth_color = null;

  triple_density_color = null;

  obj_props_density_color = null;

  data_props_density_color = null;

  _init_modes = function() {
    /* classes
    */

    /* WARNING this is done explicitly, to handpick colors for important regions and avoid similar color in neighboring regions
    */

    var classes, colors;
    classes = ["", "", "", "", "", "", "", ""];
    colors = classes.map(function(c, i) {
      var chroma;
      chroma = c === "http://dbpedia.org/ontology/TimePeriod" || c === "http://dbpedia.org/ontology/CareerStation" || c === "http://dbpedia.org/ontology/PersonFunction" || c === "http://www.opengis.net/gml/_Feature" || c === "http://dbpedia.org/ontology/Sales" ? 30 : 55;
      return d3.hcl(15 + i * 30, chroma, 70);
    });
    inset_color = d3.scale.ordinal().domain(classes).range(colors);
    /* depth
    */

    depth_color = d3.scale.linear().domain([0, ontology.levels.length - 1]).range([d3.hcl(360, 30, 30), d3.hcl(200, 0, 90)]).interpolate(d3.interpolateHcl);
    /* triple density
    */

    triple_density_color = d3.scale.linear().domain([
      0, d3.max(map.leaf_regions, function(f) {
        if (f.properties.node.name != "http://data.linkedmdb.org/resource/untyped")
          return f.properties.node.stats.triple_density;
      })
    ]).range([d3.hcl(100, 0, 90), d3.hcl(260, 30, 30)]).interpolate(d3.interpolateHcl);
    /* object properties density
    */

    obj_props_density_color = d3.scale.linear().domain([
      0, d3.max(map.leaf_regions, function(f) {
        if (f.properties.node.name != "http://data.linkedmdb.org/resource/untyped")
          return f.properties.node.stats.obj_props_density;
      })
    ]).range([d3.hcl(0, 0, 90), d3.hcl(160, 30, 30)]).interpolate(d3.interpolateHcl);
    /* data properties density
    */

    return data_props_density_color = d3.scale.linear().domain([
      0, d3.max(map.leaf_regions, function(f) {
        if (f.properties.node.name != "http://data.linkedmdb.org/resource/untyped")
          return f.properties.node.stats.data_props_density;
      })
    ]).range([d3.hcl(50, 0, 90), d3.hcl(210, 30, 30)]).interpolate(d3.interpolateHcl);
  };

  map.mode = function(requested_mode) {
    switch (requested_mode) {
      case 'classes':
        land_layer.selectAll('.leaf_region').attr({
          fill: '#D8D6CC'
        });
        land_layer.selectAll('.high_region').attr({
          stroke: function(n) {
            return inset_color(n.name);
          },
          'stroke-width': '12px'
        });
        break;
      case 'depth':
        land_layer.selectAll('.leaf_region').attr({
          fill: function(r) {
            return depth_color(r.properties.node.depth);
          }
        });
        land_layer.selectAll('.high_region').attr({
          'stroke-width': 0
        });
        break;
      case 'triple_density':
        land_layer.selectAll('.leaf_region').attr({
          fill: function(r) {
            if (r.properties.node.name != "http://data.linkedmdb.org/resource/untyped")
              return triple_density_color(r.properties.node.stats.triple_density);
          }
        });
        land_layer.selectAll('.high_region').attr({
          'stroke-width': 0
        });
        break;
      case 'obj_props_density':
        land_layer.selectAll('.leaf_region').attr({
          fill: function(r) {
            if (r.properties.node.name != "http://data.linkedmdb.org/resource/untyped")
              return obj_props_density_color(r.properties.node.stats.obj_props_density);
          }
        });
        land_layer.selectAll('.high_region').attr({
          'stroke-width': 0
        });
        break;
      case 'data_props_density':
        land_layer.selectAll('.leaf_region').attr({
          fill: function(r) {
            if (r.properties.node.name != "http://data.linkedmdb.org/resource/untyped")
              return data_props_density_color(r.properties.node.stats.data_props_density);
          }
        });
        land_layer.selectAll('.high_region').attr({
          'stroke-width': 0
        });
    }
    return map;
  };

  _draw_leaf_labels = function() {
    var enter_leaf_labels, enter_text, leaf_labels, tspans;
    leaf_labels = leaf_labels_layer.selectAll('.leaf_label').data(ontology.leaves.filter(function(n) {
      return n.depth > 1 && (n.leaf_region != null);
    }));
    enter_leaf_labels = leaf_labels.enter().append('g').attr({
      "class": 'leaf_label',
      transform: function(n) {
        return "translate(" + n.x + "," + n.y + ")";
      }
    });
    enter_text = enter_leaf_labels.append('text').attr({
      "class": 'label',
      transform: 'rotate(60)'
    });
    tspans = enter_text.selectAll('tspan').data(function(n) {
      return n.readable_label;
    });
    return tspans.enter().append('tspan').text(function(t) {
      return t;
    }).attr({
      x: 0,
      dy: '1.2em'
    });
  };

}).call(this);
